{"name":"pipeR","tagline":"Pipe operator and function based on syntax","body":"\r\n\r\n# pipeR\r\n\r\n[![Build Status](https://travis-ci.org/renkun-ken/pipeR.png?branch=master)](https://travis-ci.org/renkun-ken/pipeR)\r\n\r\n\r\npipeR provides Pipe operator and function based on syntax which support to pipe value to first-argument of a function, to dot in expression, by formula as lambda expression, for side-effect, and with assignment. The set of syntax is designed to make the pipeline highly readable.\r\n\r\n**[pipeR Tutorial](http://renkun.me/pipeR-tutorial) is a highly recommended complete guide to pipeR.**\r\n\r\n## Installation\r\n\r\nInstall from [CRAN](http://cran.r-project.org/web/packages/pipeR/index.html):\r\n\r\n```r\r\ninstall.packages(\"pipeR\")\r\n```\r\n\r\nInstall the development version from GitHub:\r\n\r\n```r\r\ndevtools::install_github(\"renkun-ken/pipeR\")\r\n```\r\n\r\n## Motivation\r\n\r\nThe following code is an example written in traditional approach:\r\n\r\nIt basically performs bootstrap on `mpg` values in built-in dataset `mtcars` and plots  its density function estimated by Gaussian kernel.\r\n\r\n```r\r\nplot(density(sample(mtcars$mpg, size = 10000, replace = TRUE), \r\n  kernel = \"gaussian\"), col = \"red\", main=\"density of mpg (bootstrap)\")\r\n```\r\n\r\nThe code is deeply nested and can be hard to read and maintain. With Pipe operator, it can be reorganized to\r\n\r\n```r\r\nmtcars$mpg %>>%\r\n  sample(size = 10000, replace = TRUE) %>>%\r\n  density(kernel = \"gaussian\") %>>%\r\n  plot(col = \"red\", main = \"density of mpg (bootstrap)\")\r\n```\r\n\r\nThe code becomes much cleaner, more readable and more maintainable.\r\n\r\n## Usage\r\n\r\n### `%>>%`\r\n\r\nPipe operator `%>>%` basically pipes the left-hand side value forward to the right-hand side expression which is evaluated according to its syntax.\r\n\r\n#### Pipe to first-argument of function\r\n\r\nMany R functions are pipe-friendly: they take some data by the first argument and transform it in a certain way. This arrangement allows operations to be streamlined by pipes, that is, one data source can be put to the first argument of a function, get transformed, and put to the first argument of the next function. In this way, a chain of commands are connected, and it is called a pipeline.\r\n\r\nOn the right-hand side of `%>>%`, whenever a function name or call is supplied, the left-hand side value will always be put to the first unnamed argument to that function.\r\n\r\n```r\r\nrnorm(100) %>>%\r\n  plot\r\n```\r\n\r\n```r\r\nrnorm(100) %>>%\r\n  plot(col=\"red\")\r\n```\r\n\r\nSometimes the value on the left is needed at multiple places. One can use `.` to represent it anywhere in the function call.\r\n\r\n```r\r\nrnorm(100) %>>%\r\n  plot(col=\"red\", main=length(.))\r\n```\r\n\r\nThere are situations where one calls a function in a namespace with `::`. In this case, the call must end up with `()`.\r\n\r\n```r\r\nrnorm(100) %>>%\r\n  stats::median()\r\n  \r\nrnorm(100) %>>%\r\n  graphics::plot(col = \"red\")\r\n```\r\n\r\n#### Pipe to `.` in an expression\r\n\r\nNot all functions are pipe-friendly in every case: You may find some functions do not take your data produced by a pipeline as the first argument. In this case, you can enclose your expression by `{}` or `()` so that `%>>%` will use `.` to represent the value on the left.\r\n\r\n```r\r\nmtcars %>>%\r\n  { lm(mpg ~ cyl + wt, data = .) }\r\n```\r\n\r\n```r\r\nmtcars %>>%\r\n  ( lm(mpg ~ cyl + wt, data = .) )\r\n```\r\n\r\n#### Pipe by formula as lambda expression\r\n\r\nSometimes, it may look confusing to use `.` to represent the value being piped. For example,\r\n\r\n```r\r\nmtcars %>>%\r\n  (lm(mpg ~ ., data = .))\r\n```\r\n\r\nAlthough it works perfectly, it may look ambiguous if `.` has several meanings in one line of code. \r\n\r\n`%>>%` accepts lambda expression to direct its piping behavior. Lambda expression is characterized by a formula enclosed within `()`, for example, `(x ~ f(x))`. It contains a user-defined symbol to represent the value being piped and the expression to be evaluated.\r\n\r\n```r\r\nmtcars %>>%\r\n  (df ~ lm(mpg ~ ., data = df))\r\n```\r\n\r\n```r\r\nmtcars %>>%\r\n  subset(select = c(mpg, wt, cyl)) %>>%\r\n  (x ~ plot(mpg ~ ., data = x))\r\n```\r\n\r\n#### Pipe for side effect\r\n\r\nIn a pipeline, one may be interested not only in the final outcome but sometimes also in intermediate results. To print, plot or save the intermediate results, it must be a side-effect to avoid breaking the mainstream pipeline. For example, calling `plot()` to draw scatter plot returns `NULL`, and if one directly calls `plot()` in the middle of a pipeline, it would break the pipeline by changing the subsequent input to `NULL`.\r\n\r\nOne-sided formula that starts with `~` indicates that the right-hand side expression will only be evaluated for its side-effect, its value will be ignored, and the input value will be returned instead.\r\n\r\n```r\r\nmtcars %>>%\r\n  subset(mpg >= quantile(mpg, 0.05) & mpg <= quantile(mpg, 0.95)) %>>%\r\n  (~ cat(\"rows:\",nrow(.),\"\\n\")) %>>%   # cat() returns NULL\r\n  summary\r\n```\r\n\r\n```r\r\nmtcars %>>%\r\n  subset(mpg >= quantile(mpg, 0.05) & mpg <= quantile(mpg, 0.95)) %>>%\r\n  (~ plot(mpg ~ wt, data = .)) %>>%    # plot() returns NULL\r\n  (lm(mpg ~ wt, data = .)) %>>%\r\n  summary()\r\n```\r\n\r\nWith `~`, side-effect operations can be easily distinguished from mainstream pipeline.\r\n\r\nAn easier way to print the intermediate value it to use `(? expr)` syntax like asking question.\r\n\r\n```r\r\nmtcars %>>% \r\n  (? ncol(.)) %>>%\r\n  summary\r\n```\r\n\r\n#### Pipe with assignment\r\n\r\nIn addition to printing and plotting, one may need to save an intermediate value to the environment by assigning the value to a variable (symbol).\r\n\r\nIf one needs to assign the value to a symbol, just insert a step like `(~ symbol)`, then the input value of that step will be assigned to `symbol` in the current environment.\r\n\r\n```r\r\nmtcars %>>%\r\n  (lm(formula = mpg ~ wt + cyl, data = .)) %>>%\r\n  (~ lm_mtcars) %>>%\r\n  summary\r\n```\r\n\r\nIf the input value is not directly to be saved but after some transformation, then one can use `=`, `<-`, or more natural `->` to specify a lambda expression to tell what to be saved (thanks @yanlinlin82 for suggestion).\r\n\r\n```r\r\nmtcars %>>%\r\n  (~ summ = summary(.)) %>>%  # side-effect assignment\r\n  (lm(formula = mpg ~ wt + cyl, data = .)) %>>%\r\n  (~ lm_mtcars) %>>%\r\n  summary\r\n```\r\n\r\n```r\r\nmtcars %>>%\r\n  (~ summary(.) -> summ) %>>%\r\n  \r\nmtcars %>>%\r\n  (~ summ <- summary(.)) %>>%\r\n```\r\n\r\nAn easier way to saving intermediate value that is to be further piped is to use `(symbol = expression)` syntax:\r\n\r\n```r\r\nmtcars %>>%\r\n  (~ summ = summary(.)) %>>%  # side-effect assignment\r\n  (lm_mtcars = lm(formula = mpg ~ wt + cyl, data = .)) %>>%  # continue piping\r\n  summary\r\n```\r\n\r\nor `(expression -> symbol)` syntax:\r\n\r\n```r\r\nmtcars %>>%\r\n  (~ summary(.) -> summ) %>>%  # side-effect assignment\r\n  (lm(formula = mpg ~ wt + cyl, data = .) -> lm_mtcars) %>>%  # continue piping\r\n  summary\r\n```\r\n\r\n#### Extract element from an object\r\n\r\n`x %>>% (y)` means extracting the element named `y` from object `x` where `y` must be a valid symbol name and `x` can be a vector, list, environment or anything else for which `[[]]` is defined, or S4 object.\r\n\r\n```r\r\nmtcars %>>%\r\n  (lm(mpg ~ wt + cyl, data = .)) %>>%\r\n  (~ lm_mtcars) %>>%\r\n  summary %>>%\r\n  (r.squared)\r\n```\r\n\r\n#### Compatibility\r\n\r\n* Working with [dplyr](https://github.com/hadley/dplyr/):\r\n\r\n```r\r\nlibrary(dplyr)\r\nmtcars %>>%\r\n  filter(mpg <= mean(mpg)) %>>%  \r\n  select(mpg, wt, cyl) %>>%\r\n  (~ plot(.)) %>>%\r\n  (model = lm(mpg ~ wt + cyl, data = .)) %>>%\r\n  (summ = summary(.)) %>>%\r\n  (coefficients)\r\n```\r\n\r\n* Working with [ggvis](http://ggvis.rstudio.com/):\r\n\r\n```r\r\nlibrary(ggvis)\r\nmtcars %>>%\r\n  ggvis(~mpg, ~wt) %>>%\r\n  layer_points()\r\n```\r\n\r\n* Working with [rlist](http://renkun.me/rlist/):\r\n\r\n```r\r\nlibrary(rlist)\r\n1:100 %>>%\r\n  list.group(. %% 3) %>>%\r\n  list.mapv(g ~ mean(g))\r\n```\r\n\r\n### `Pipe()`\r\n\r\n`Pipe()` creates a Pipe object that supports light-weight chaining without any external operator. Typically, start with `Pipe()` and end with `$value` or `[]` to extract the final value of the Pipe. \r\n\r\nPipe object provides an internal function `.(...)` that work exactly in the same way with `x %>>% (...)`, and it has more features than `%>>%`.\r\n\r\n> NOTE: `.()` does not support assignment with `=` but supports `~`, `<-` and `->`.\r\n\r\n#### Piping\r\n\r\n```r\r\nPipe(rnorm(1000))$\r\n  density(kernel = \"cosine\")$\r\n  plot(col = \"blue\")\r\n```\r\n\r\n```r\r\nPipe(mtcars)$\r\n  .(mpg)$\r\n  summary()\r\n```\r\n\r\n```r\r\nPipe(mtcars)$\r\n  .(~ summary(.) -> summ)$\r\n  lm(formula = mpg ~ wt + cyl)$\r\n  summary()$\r\n  .(coefficients)\r\n```\r\n\r\n#### Subsetting and extracting\r\n\r\n```r\r\npmtcars <- Pipe(mtcars)\r\npmtcars[c(\"mpg\",\"wt\")]$\r\n  lm(formula = mpg ~ wt)$\r\n  summary()\r\npmtcars[[\"mpg\"]]$mean()\r\n```\r\n\r\n#### Assigning values\r\n\r\n```r\r\nplist <- Pipe(list(a=1,b=2))\r\nplist$a <- 0\r\nplist$b <- NULL\r\n```\r\n\r\n#### Side effect\r\n\r\n```r\r\nPipe(mtcars)$\r\n  .(? ncol(.))$\r\n  .(~ plot(mpg ~ ., data = .))$    # side effect: plot\r\n  lm(formula = mpg ~ .)$\r\n  .(~ lm_mtcars)$                  # side effect: assign\r\n  summary()$\r\n```\r\n\r\n#### Compatibility\r\n\r\n* Working with dplyr:\r\n\r\n```r\r\nPipe(mtcars)$\r\n  filter(mpg >= mean(mpg))$\r\n  select(mpg, wt, cyl)$\r\n  lm(formula = mpg ~ wt + cyl)$\r\n  summary()$\r\n  .(coefficients)$\r\n  value\r\n```\r\n\r\n* Working with ggvis:\r\n\r\n```r\r\nPipe(mtcars)$\r\n  ggvis(~ mpg, ~ wt)$\r\n  layer_points()\r\n```\r\n\r\n* Working with rlist:\r\n\r\n```r\r\nPipe(1:100)$\r\n  list.group(. %% 3)$\r\n  list.mapv(g ~ mean(g))$\r\n  value\r\n```\r\n\r\n## Help overview\r\n\r\n```r\r\nhelp(package = pipeR)\r\n```\r\n\r\n## License\r\n\r\nThis package is under [MIT License](http://opensource.org/licenses/MIT).\r\n","google":"UA-47159422-1","note":"Don't delete this file! It's used internally to help with page regeneration."}